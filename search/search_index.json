{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Langage de programmation Sway Sway est un langage d\u00e9di\u00e9 ( domain-specific language ) pour la Fuel Virtual Machine (FuelVM) , une VM optimis\u00e9e pour la blockchain, con\u00e7ue pour la blockchain Fuel. Sway est bas\u00e9 sur Rust et comprend une syntaxe permettant de tirer parti d'une VM de blockchain sans avoir recours \u00e0 un langage passe-partout inutilement verbeux. Cette documentation explique comment r\u00e9diger des contrats intelligents ( smart contracts ) avec Sway, et comment installer et utiliser la Sway toolchain. Avant de commencer \u00e0 d\u00e9velopper des smart contracts en Sway, gardez \u00e0 l'esprit les probl\u00e8mes connus et les diff\u00e9rentes solutions de contournement mise en place.","title":"Accueil"},{"location":"#langage-de-programmation-sway","text":"Sway est un langage d\u00e9di\u00e9 ( domain-specific language ) pour la Fuel Virtual Machine (FuelVM) , une VM optimis\u00e9e pour la blockchain, con\u00e7ue pour la blockchain Fuel. Sway est bas\u00e9 sur Rust et comprend une syntaxe permettant de tirer parti d'une VM de blockchain sans avoir recours \u00e0 un langage passe-partout inutilement verbeux. Cette documentation explique comment r\u00e9diger des contrats intelligents ( smart contracts ) avec Sway, et comment installer et utiliser la Sway toolchain. Avant de commencer \u00e0 d\u00e9velopper des smart contracts en Sway, gardez \u00e0 l'esprit les probl\u00e8mes connus et les diff\u00e9rentes solutions de contournement mise en place.","title":"Langage de programmation Sway"},{"location":"introduction/Bibliotheque%20standard/","text":"Biblioth\u00e8que standard Comme pour Rust, Sway dispose de sa propre biblioth\u00e8que standard. La biblioth\u00e8que standard de Sway est la base du logiciel portable Sway, un ensemble d'abstractions minimales partag\u00e9es pour l'ensemble de l'\u00e9cosyst\u00e8me Sway. Elle offre des types de base, comme R\u00e9sult<T, E> et Option<T> , des op\u00e9rations d\u00e9finies par la biblioth\u00e8que sur les primitives du langage, la gestion native des actifs, les op\u00e9rations contextuelles de la blockchain, le contr\u00f4le d'acc\u00e8s, la gestion du stockage et la prise en charge des types d'autres VM, entre autres choses. L'ensemble de la biblioth\u00e8que standard de Sway est un projet Forc appel\u00e9 std , et est disponible directement ici : https://github.com/FuelLabs/sway/tree/master/sway-lib-std (naviguez vers la version appropri\u00e9e si la derni\u00e8re version master n'est pas compatible). Utilisation de la biblioth\u00e8que standard La biblioth\u00e8que standard est rendue implicitement disponible pour tous les projets Forc cr\u00e9\u00e9s \u00e0 l'aide de forc new . En d'autres termes, il n'est pas n\u00e9cessaire de sp\u00e9cifier manuellement std comme une d\u00e9pendance explicite. Forc utilisera automatiquement la version de std qui correspond \u00e0 sa version. L'importation d'\u00e9l\u00e9ments de la biblioth\u00e8que standard peut \u00eatre faite en utilisant le mot-cl\u00e9 use , tout comme l'importation d'\u00e9l\u00e9ments de n'importe quel projet Sway. Par exemple use std::storage::StorageMap ; Ceci importe le type StorageMap dans l'espace de nom courant. Pr\u00e9lude \u00e0 la biblioth\u00e8que standard Sway est livr\u00e9 avec une grande vari\u00e9t\u00e9 de choses dans sa biblioth\u00e8que standard. Cependant, si vous deviez importer manuellement chaque chose que vous utilisez, ce serait tr\u00e8s verbeux. Mais importer beaucoup de choses qu'un programme n'utilise jamais n'est pas bon non plus. Un \u00e9quilibre doit \u00eatre trouv\u00e9. Le pr\u00e9lude est la liste des choses que Sway importe automatiquement dans chaque programme Sway. Elle est aussi r\u00e9duite que possible et se concentre sur les \u00e9l\u00e9ments qui sont utilis\u00e9s dans presque tous les programmes Sway. La version actuelle du prelude se trouve dans std::prelude , et r\u00e9exporte les \u00e9l\u00e9ments suivants : std::address::Address , une enveloppe autour du type b256 repr\u00e9sentant une adresse de portefeuille. std::contract_id::ContractId , une enveloppe autour du type b256 repr\u00e9sentant l'ID d'un contrat. std::identity::Identity , un enum avec deux variantes possibles : Address : Address et ContractId : ContractId . std::vec::Vec , un vecteur croissant, allou\u00e9 au tas. std::option::Option , un enum qui exprime la pr\u00e9sence ou l'absence d'une valeur. std::result::Resultat , un enum pour les fonctions qui peuvent r\u00e9ussir ou \u00e9chouer. std::assert::assert , une fonction qui renvoie la VM si la condition qui lui est fournie est false . std::revert::require , une fonction qui renverse la VM et enregistre une valeur donn\u00e9e si la condition qui lui est fournie est false . std::revert::revert , une fonction qui renverse la VM.","title":"Bibliotheque standard"},{"location":"introduction/Bibliotheque%20standard/#bibliotheque-standard","text":"Comme pour Rust, Sway dispose de sa propre biblioth\u00e8que standard. La biblioth\u00e8que standard de Sway est la base du logiciel portable Sway, un ensemble d'abstractions minimales partag\u00e9es pour l'ensemble de l'\u00e9cosyst\u00e8me Sway. Elle offre des types de base, comme R\u00e9sult<T, E> et Option<T> , des op\u00e9rations d\u00e9finies par la biblioth\u00e8que sur les primitives du langage, la gestion native des actifs, les op\u00e9rations contextuelles de la blockchain, le contr\u00f4le d'acc\u00e8s, la gestion du stockage et la prise en charge des types d'autres VM, entre autres choses. L'ensemble de la biblioth\u00e8que standard de Sway est un projet Forc appel\u00e9 std , et est disponible directement ici : https://github.com/FuelLabs/sway/tree/master/sway-lib-std (naviguez vers la version appropri\u00e9e si la derni\u00e8re version master n'est pas compatible).","title":"Biblioth\u00e8que standard"},{"location":"introduction/Bibliotheque%20standard/#utilisation-de-la-bibliotheque-standard","text":"La biblioth\u00e8que standard est rendue implicitement disponible pour tous les projets Forc cr\u00e9\u00e9s \u00e0 l'aide de forc new . En d'autres termes, il n'est pas n\u00e9cessaire de sp\u00e9cifier manuellement std comme une d\u00e9pendance explicite. Forc utilisera automatiquement la version de std qui correspond \u00e0 sa version. L'importation d'\u00e9l\u00e9ments de la biblioth\u00e8que standard peut \u00eatre faite en utilisant le mot-cl\u00e9 use , tout comme l'importation d'\u00e9l\u00e9ments de n'importe quel projet Sway. Par exemple use std::storage::StorageMap ; Ceci importe le type StorageMap dans l'espace de nom courant.","title":"Utilisation de la biblioth\u00e8que standard"},{"location":"introduction/Bibliotheque%20standard/#prelude-a-la-bibliotheque-standard","text":"Sway est livr\u00e9 avec une grande vari\u00e9t\u00e9 de choses dans sa biblioth\u00e8que standard. Cependant, si vous deviez importer manuellement chaque chose que vous utilisez, ce serait tr\u00e8s verbeux. Mais importer beaucoup de choses qu'un programme n'utilise jamais n'est pas bon non plus. Un \u00e9quilibre doit \u00eatre trouv\u00e9. Le pr\u00e9lude est la liste des choses que Sway importe automatiquement dans chaque programme Sway. Elle est aussi r\u00e9duite que possible et se concentre sur les \u00e9l\u00e9ments qui sont utilis\u00e9s dans presque tous les programmes Sway. La version actuelle du prelude se trouve dans std::prelude , et r\u00e9exporte les \u00e9l\u00e9ments suivants : std::address::Address , une enveloppe autour du type b256 repr\u00e9sentant une adresse de portefeuille. std::contract_id::ContractId , une enveloppe autour du type b256 repr\u00e9sentant l'ID d'un contrat. std::identity::Identity , un enum avec deux variantes possibles : Address : Address et ContractId : ContractId . std::vec::Vec , un vecteur croissant, allou\u00e9 au tas. std::option::Option , un enum qui exprime la pr\u00e9sence ou l'absence d'une valeur. std::result::Resultat , un enum pour les fonctions qui peuvent r\u00e9ussir ou \u00e9chouer. std::assert::assert , une fonction qui renvoie la VM si la condition qui lui est fournie est false . std::revert::require , une fonction qui renverse la VM et enregistre une valeur donn\u00e9e si la condition qui lui est fournie est false . std::revert::revert , une fonction qui renverse la VM.","title":"Pr\u00e9lude \u00e0 la biblioth\u00e8que standard"},{"location":"introduction/demarrage/","text":"D\u00e9marrage Suivez ce guide pour \u00e9crire, tester et d\u00e9ployer un contrat intelligent simple dans Sway. Glossaire Avant de commencer, il peut \u00eatre utile de comprendre la terminologie qui sera utilis\u00e9e tout au long de la documentation et la fa\u00e7on dont elle se rapporte les uns aux autres : Fuel : la blockchain Fuel. FuelVM : la machine virtuelle qui alimente Fuel. Sway : le langage sp\u00e9cifique au domaine con\u00e7u pour la FuelVM ; il est inspir\u00e9 de Rust. Forc : le syst\u00e8me de construction et le gestionnaire de paquets pour Sway, similaire \u00e0 Cargo pour Rust. Comprendre les types de programmes Sway Il existe quatre types de programmes Sway : contrat predicate script library (biblioth\u00e8que) Les contrats, pr\u00e9dicats et scripts peuvent produire des artefacts utilisables sur la blockchain, tandis qu'une biblioth\u00e8que est simplement un projet con\u00e7u pour la r\u00e9utilisation du code et n'est pas directement d\u00e9ployable. Voir le chapitre sur les types de programmes pour plus d'informations. Votre premier projet Sway Nous allons construire un contrat de compteur simple avec deux fonctions : une pour incr\u00e9menter le compteur, et une pour retourner la valeur du compteur. Quelques informations qui seront utiles avant de continuer : Les principales caract\u00e9ristiques d'un contrat intelligent qui le diff\u00e9rencient des scripts ou des pr\u00e9dicats sont qu'il est appelable et avec \u00e9tat. Un script est un bytecode ex\u00e9cutable sur la cha\u00eene qui peut appeler des contrats pour effectuer une t\u00e2che. Il ne repr\u00e9sente pas la propri\u00e9t\u00e9 d'une ressource et ne peut pas \u00eatre appel\u00e9 par un contrat. \u00c9crire le contrat Tout d'abord, installons la toolchain Sway . Puis, avec forc install\u00e9, cr\u00e9ons un projet de contrat : forc new counter_contract Voici le projet que Forc a initialis\u00e9 : $ cd counter_contract $ tree . \u251c\u2500\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Forc.toml \u251c\u2500\u2500\u2500 src \u2502 \u2514\u2500\u2500\u2500 main.sw \u2514\u2500\u2500\u2500 tests \u2514\u2500\u2500\u2500 harness.rs Forc.toml est le fichier de manifeste (similaire \u00e0 Cargo.toml pour Cargo ou package.json pour Node), et d\u00e9finit les m\u00e9tadonn\u00e9es du projet telles que le nom du projet et les d\u00e9pendances. Nous allons \u00e9crire notre code dans le dossier src/main.sw . Changez de r\u00e9pertoire dans votre projet de contrat et supprimez le code passe-partout dans src/main.sw . Chaque fichier Sway doit commencer par une d\u00e9claration du type de programme qu'il contient ; ici, nous avons d\u00e9clar\u00e9 que ce fichier est un contrat. contrat ; Ensuite, nous allons d\u00e9finir une valeur de stockage. Dans notre cas, nous avons un seul compteur que nous appellerons counter de type 64-bit unsigned integer et l'initialiserons \u00e0 0. storage { compteur : u64 = 0, } ABI Une ABI d\u00e9finit une interface, et il n'y a pas de corps de fonction dans l'ABI. Un contrat doit soit d\u00e9finir, soit importer une d\u00e9claration ABI et l'impl\u00e9menter. Il est consid\u00e9r\u00e9 comme une bonne pratique de d\u00e9finir votre ABI dans une biblioth\u00e8que s\u00e9par\u00e9e et de l'importer dans votre contrat car cela permet aux appelants du contrat d'importer et d'utiliser l'ABI dans des scripts pour appeler votre contrat. Pour plus de simplicit\u00e9, nous allons d\u00e9finir l'ABI de mani\u00e8re native dans le contrat. abi Counter { #[stockage(read, write)] fn increment() ; #[stockage(lecture)] fn counter() -> u64 ; } Aller ligne par ligne #[storage(read, write)] est une annotation qui indique que cette fonction a la permission de lire et d'\u00e9crire une valeur dans le stockage. fn increment() - Nous introduisons la fonctionnalit\u00e9 d'incr\u00e9mentation et indiquons qu'elle ne doit pas retourner de valeur. #[storage(read)] est une annotation qui indique que cette fonction a la permission de lire des valeurs dans le stockage. fn counter() -> u64; - Nous introduisons la fonctionnalit\u00e9 d'incr\u00e9mentation du compteur et indiquons la valeur de retour de la fonction. Implement ABI Sous la d\u00e9finition de votre ABI, vous \u00e9crirez l'impl\u00e9mentation des fonctions d\u00e9finies dans votre ABI. impl Compteur pour Contrat { #[stockage(read)] fn counter() -> u64 { return storage.counter ; } #[stockage(read, write)] fn increment() { storage.counter = storage.counter + 1 ; } } Note return storage.counter; est \u00e9quivalent \u00e0 storage.counter . Ce que nous venons de faire Lire et retourner la valeur de la propri\u00e9t\u00e9 counter du stockage du contrat. fn counter() -> u64 { retourne storage.counter ; } Le corps de la fonction acc\u00e8de \u00e0 la valeur du compteur dans le stockage, et incr\u00e9mente la valeur de un. Ensuite, nous retournons la nouvelle valeur mise \u00e0 jour du compteur. fn increment() { storage.counter = storage.counter + 1 ; } Construire le contrat Construisez counter_contract en ex\u00e9cutant la commande suivante dans votre terminal depuis le r\u00e9pertoire counter_contract : forc build Vous devriez voir quelque chose comme cette sortie : Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets. D\u00e9ployer le contrat Il est maintenant temps de d\u00e9ployer le contrat et de l'appeler sur un n\u0153ud Fuel. Nous allons montrer comment le faire en utilisant forc en ligne de commande, mais vous pouvez aussi le faire en utilisant le Rust SDK ou le TypeScript SDK . Faite tourner votre noeud Fuel Dans un onglet s\u00e9par\u00e9 de votre terminal, cr\u00e9ez un n\u0153ud Fuel local : fuel-core run --db-type in-memory Ceci d\u00e9marre un noeud Fuel avec une base de donn\u00e9es volatile qui sera effac\u00e9e \u00e0 l'arr\u00eat (bon pour les tests). D\u00e9ployer counter_contract vers votre noeud Fuel local Pour d\u00e9ployer counter_contract sur votre noeud Fuel local, ouvrez un nouvel onglet de terminal et ex\u00e9cutez la commande suivante depuis la racine du r\u00e9pertoire wallet_contract : forc deploy --unsigned Note Vous ne pouvez pas utiliser la m\u00eame session de terminal qui ex\u00e9cute fuel-core pour ex\u00e9cuter d'autres commandes car cela mettrait fin \u00e0 votre processus fuel-core. Ceci devrait produire une sortie dans stdout qui ressemble \u00e0 ceci : $ forc deploy --unsigned Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets. Contract id: 0xaf94c0a707756caae667ee43ca18bace441b25998c668010192444a19674dc4f Journaux : TransactionId(HexFormatted(7cef24ea33513733ab78c5daa5328d622d4b38187d0f0d1857b272090d99f96a)) Notez l'identifiant du contrat - vous en aurez besoin si vous voulez construire un frontend pour interagir avec ce contrat. Test de votre contrat Dans le r\u00e9pertoire tests , naviguez jusqu'\u00e0 harness.rs. Ici vous verrez qu'il y a un peu de code passe-partout pour vous aider \u00e0 commencer \u00e0 interagir avec et \u00e0 tester votre contrat. Au bas du fichier, d\u00e9finissez le corps de can_get_contract_instance . Voici \u00e0 quoi devrait ressembler votre code pour v\u00e9rifier que la valeur du compteur a bien \u00e9t\u00e9 incr\u00e9ment\u00e9e : #[tokio::test] async fn can_get_contract_instance() { // Incr\u00e9mente le compteur let _result = instance.increment().call().await.unwrap() ; // R\u00e9cup\u00e8re la valeur actuelle du compteur let result = instance.counter().call().await.unwrap() ; assert !(result.value > 0) ; } Ex\u00e9cutez la commande suivante dans le terminal : forc test . Vous verrez quelque chose comme ceci dans votre sortie : Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets. Compilation de counter_contract v0.1.0 (<path/to/counter_contract>) Termin\u00e9 test [unoptimized + debuginfo] cible(s) en 4.55s Ex\u00e9cution de tests/harness.rs (target/debug/deps/integration_tests-7a2922c770587b45) Ex\u00e9cution de 1 test test can_get_contract_id ... ok R\u00e9sultat du test : ok. 1 r\u00e9ussi ; 0 \u00e9chou\u00e9 ; 0 ignor\u00e9 ; 0 mesur\u00e9 ; 0 filtr\u00e9 ; termin\u00e9 en 0.09s F\u00e9licitations, vous venez de cr\u00e9er et de tester votre premier contrat intelligent Sway \ud83c\udf89. Vous pouvez maintenant construire un frontend pour interagir avec votre contrat en utilisant le SDK TypeScript. Vous pouvez trouver un guide \u00e9tape par \u00e9tape pour construire un front-end pour votre projet ici .","title":"D\u00e9marrage"},{"location":"introduction/demarrage/#demarrage","text":"Suivez ce guide pour \u00e9crire, tester et d\u00e9ployer un contrat intelligent simple dans Sway.","title":"D\u00e9marrage"},{"location":"introduction/demarrage/#glossaire","text":"Avant de commencer, il peut \u00eatre utile de comprendre la terminologie qui sera utilis\u00e9e tout au long de la documentation et la fa\u00e7on dont elle se rapporte les uns aux autres : Fuel : la blockchain Fuel. FuelVM : la machine virtuelle qui alimente Fuel. Sway : le langage sp\u00e9cifique au domaine con\u00e7u pour la FuelVM ; il est inspir\u00e9 de Rust. Forc : le syst\u00e8me de construction et le gestionnaire de paquets pour Sway, similaire \u00e0 Cargo pour Rust.","title":"Glossaire"},{"location":"introduction/demarrage/#comprendre-les-types-de-programmes-sway","text":"Il existe quatre types de programmes Sway : contrat predicate script library (biblioth\u00e8que) Les contrats, pr\u00e9dicats et scripts peuvent produire des artefacts utilisables sur la blockchain, tandis qu'une biblioth\u00e8que est simplement un projet con\u00e7u pour la r\u00e9utilisation du code et n'est pas directement d\u00e9ployable. Voir le chapitre sur les types de programmes pour plus d'informations.","title":"Comprendre les types de programmes Sway"},{"location":"introduction/demarrage/#votre-premier-projet-sway","text":"Nous allons construire un contrat de compteur simple avec deux fonctions : une pour incr\u00e9menter le compteur, et une pour retourner la valeur du compteur. Quelques informations qui seront utiles avant de continuer : Les principales caract\u00e9ristiques d'un contrat intelligent qui le diff\u00e9rencient des scripts ou des pr\u00e9dicats sont qu'il est appelable et avec \u00e9tat. Un script est un bytecode ex\u00e9cutable sur la cha\u00eene qui peut appeler des contrats pour effectuer une t\u00e2che. Il ne repr\u00e9sente pas la propri\u00e9t\u00e9 d'une ressource et ne peut pas \u00eatre appel\u00e9 par un contrat.","title":"Votre premier projet Sway"},{"location":"introduction/demarrage/#ecrire-le-contrat","text":"Tout d'abord, installons la toolchain Sway . Puis, avec forc install\u00e9, cr\u00e9ons un projet de contrat : forc new counter_contract Voici le projet que Forc a initialis\u00e9 : $ cd counter_contract $ tree . \u251c\u2500\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Forc.toml \u251c\u2500\u2500\u2500 src \u2502 \u2514\u2500\u2500\u2500 main.sw \u2514\u2500\u2500\u2500 tests \u2514\u2500\u2500\u2500 harness.rs Forc.toml est le fichier de manifeste (similaire \u00e0 Cargo.toml pour Cargo ou package.json pour Node), et d\u00e9finit les m\u00e9tadonn\u00e9es du projet telles que le nom du projet et les d\u00e9pendances. Nous allons \u00e9crire notre code dans le dossier src/main.sw . Changez de r\u00e9pertoire dans votre projet de contrat et supprimez le code passe-partout dans src/main.sw . Chaque fichier Sway doit commencer par une d\u00e9claration du type de programme qu'il contient ; ici, nous avons d\u00e9clar\u00e9 que ce fichier est un contrat. contrat ; Ensuite, nous allons d\u00e9finir une valeur de stockage. Dans notre cas, nous avons un seul compteur que nous appellerons counter de type 64-bit unsigned integer et l'initialiserons \u00e0 0. storage { compteur : u64 = 0, }","title":"\u00c9crire le contrat"},{"location":"introduction/demarrage/#abi","text":"Une ABI d\u00e9finit une interface, et il n'y a pas de corps de fonction dans l'ABI. Un contrat doit soit d\u00e9finir, soit importer une d\u00e9claration ABI et l'impl\u00e9menter. Il est consid\u00e9r\u00e9 comme une bonne pratique de d\u00e9finir votre ABI dans une biblioth\u00e8que s\u00e9par\u00e9e et de l'importer dans votre contrat car cela permet aux appelants du contrat d'importer et d'utiliser l'ABI dans des scripts pour appeler votre contrat. Pour plus de simplicit\u00e9, nous allons d\u00e9finir l'ABI de mani\u00e8re native dans le contrat. abi Counter { #[stockage(read, write)] fn increment() ; #[stockage(lecture)] fn counter() -> u64 ; }","title":"ABI"},{"location":"introduction/demarrage/#aller-ligne-par-ligne","text":"#[storage(read, write)] est une annotation qui indique que cette fonction a la permission de lire et d'\u00e9crire une valeur dans le stockage. fn increment() - Nous introduisons la fonctionnalit\u00e9 d'incr\u00e9mentation et indiquons qu'elle ne doit pas retourner de valeur. #[storage(read)] est une annotation qui indique que cette fonction a la permission de lire des valeurs dans le stockage. fn counter() -> u64; - Nous introduisons la fonctionnalit\u00e9 d'incr\u00e9mentation du compteur et indiquons la valeur de retour de la fonction.","title":"Aller ligne par ligne"},{"location":"introduction/demarrage/#implement-abi","text":"Sous la d\u00e9finition de votre ABI, vous \u00e9crirez l'impl\u00e9mentation des fonctions d\u00e9finies dans votre ABI. impl Compteur pour Contrat { #[stockage(read)] fn counter() -> u64 { return storage.counter ; } #[stockage(read, write)] fn increment() { storage.counter = storage.counter + 1 ; } } Note return storage.counter; est \u00e9quivalent \u00e0 storage.counter .","title":"Implement ABI"},{"location":"introduction/demarrage/#ce-que-nous-venons-de-faire","text":"Lire et retourner la valeur de la propri\u00e9t\u00e9 counter du stockage du contrat. fn counter() -> u64 { retourne storage.counter ; } Le corps de la fonction acc\u00e8de \u00e0 la valeur du compteur dans le stockage, et incr\u00e9mente la valeur de un. Ensuite, nous retournons la nouvelle valeur mise \u00e0 jour du compteur. fn increment() { storage.counter = storage.counter + 1 ; }","title":"Ce que nous venons de faire"},{"location":"introduction/demarrage/#construire-le-contrat","text":"Construisez counter_contract en ex\u00e9cutant la commande suivante dans votre terminal depuis le r\u00e9pertoire counter_contract : forc build Vous devriez voir quelque chose comme cette sortie : Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets.","title":"Construire le contrat"},{"location":"introduction/demarrage/#deployer-le-contrat","text":"Il est maintenant temps de d\u00e9ployer le contrat et de l'appeler sur un n\u0153ud Fuel. Nous allons montrer comment le faire en utilisant forc en ligne de commande, mais vous pouvez aussi le faire en utilisant le Rust SDK ou le TypeScript SDK .","title":"D\u00e9ployer le contrat"},{"location":"introduction/demarrage/#faite-tourner-votre-noeud-fuel","text":"Dans un onglet s\u00e9par\u00e9 de votre terminal, cr\u00e9ez un n\u0153ud Fuel local : fuel-core run --db-type in-memory Ceci d\u00e9marre un noeud Fuel avec une base de donn\u00e9es volatile qui sera effac\u00e9e \u00e0 l'arr\u00eat (bon pour les tests).","title":"Faite tourner votre noeud Fuel"},{"location":"introduction/demarrage/#deployer-counter_contract-vers-votre-noeud-fuel-local","text":"Pour d\u00e9ployer counter_contract sur votre noeud Fuel local, ouvrez un nouvel onglet de terminal et ex\u00e9cutez la commande suivante depuis la racine du r\u00e9pertoire wallet_contract : forc deploy --unsigned Note Vous ne pouvez pas utiliser la m\u00eame session de terminal qui ex\u00e9cute fuel-core pour ex\u00e9cuter d'autres commandes car cela mettrait fin \u00e0 votre processus fuel-core. Ceci devrait produire une sortie dans stdout qui ressemble \u00e0 ceci : $ forc deploy --unsigned Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets. Contract id: 0xaf94c0a707756caae667ee43ca18bace441b25998c668010192444a19674dc4f Journaux : TransactionId(HexFormatted(7cef24ea33513733ab78c5daa5328d622d4b38187d0f0d1857b272090d99f96a)) Notez l'identifiant du contrat - vous en aurez besoin si vous voulez construire un frontend pour interagir avec ce contrat.","title":"D\u00e9ployer counter_contract vers votre noeud Fuel local"},{"location":"introduction/demarrage/#test-de-votre-contrat","text":"Dans le r\u00e9pertoire tests , naviguez jusqu'\u00e0 harness.rs. Ici vous verrez qu'il y a un peu de code passe-partout pour vous aider \u00e0 commencer \u00e0 interagir avec et \u00e0 tester votre contrat. Au bas du fichier, d\u00e9finissez le corps de can_get_contract_instance . Voici \u00e0 quoi devrait ressembler votre code pour v\u00e9rifier que la valeur du compteur a bien \u00e9t\u00e9 incr\u00e9ment\u00e9e : #[tokio::test] async fn can_get_contract_instance() { // Incr\u00e9mente le compteur let _result = instance.increment().call().await.unwrap() ; // R\u00e9cup\u00e8re la valeur actuelle du compteur let result = instance.counter().call().await.unwrap() ; assert !(result.value > 0) ; } Ex\u00e9cutez la commande suivante dans le terminal : forc test . Vous verrez quelque chose comme ceci dans votre sortie : Biblioth\u00e8que compil\u00e9e \"core\". Biblioth\u00e8que compil\u00e9e \"std\". Contrat compil\u00e9 \"counter_contract\". La taille du bytecode est de 224 octets. Compilation de counter_contract v0.1.0 (<path/to/counter_contract>) Termin\u00e9 test [unoptimized + debuginfo] cible(s) en 4.55s Ex\u00e9cution de tests/harness.rs (target/debug/deps/integration_tests-7a2922c770587b45) Ex\u00e9cution de 1 test test can_get_contract_id ... ok R\u00e9sultat du test : ok. 1 r\u00e9ussi ; 0 \u00e9chou\u00e9 ; 0 ignor\u00e9 ; 0 mesur\u00e9 ; 0 filtr\u00e9 ; termin\u00e9 en 0.09s F\u00e9licitations, vous venez de cr\u00e9er et de tester votre premier contrat intelligent Sway \ud83c\udf89. Vous pouvez maintenant construire un frontend pour interagir avec votre contrat en utilisant le SDK TypeScript. Vous pouvez trouver un guide \u00e9tape par \u00e9tape pour construire un front-end pour votre projet ici .","title":"Test de votre contrat"},{"location":"introduction/forcProject/","text":"Un projet Forc Pour initialiser un nouveau projet avec Forc, utilisez forc new : forc new mon-projet-carburant Voici le projet que Forc a initialis\u00e9 : $ cd mon-projet-carburant $ tree . \u251c\u2500\u2500\u2500 Forc.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.sw Forc.toml est le fichier de manifeste (similaire \u00e0 Cargo.toml pour Cargo ou package.json pour Node), et d\u00e9finit les m\u00e9tadonn\u00e9es du projet telles que le nom du projet et les d\u00e9pendances. Pour plus d'informations sur la gestion des d\u00e9pendances, voir : ici . [projet] auteurs = [\"Utilisateur\"] entr\u00e9e = \"main.sw\" license = \"Apache-2.0 name = \"my-fuel-project\" [d\u00e9pendances] Voici le contenu du seul fichier Sway du projet, et le point d'entr\u00e9e principal, src/main.sw : contrat ; abi MonContrat { fn test_function() -> bool ; } impl MonContrat pour Contrat { fn test_function() -> bool { true } } Le projet est un contrat , l'un des quatre types de projet diff\u00e9rents. Pour plus d'informations sur les diff\u00e9rents types de projets, voir ici . Nous compilons maintenant notre projet avec forc build , en passant le flag --print-finalized-asm pour voir l'assemblage g\u00e9n\u00e9r\u00e9 : $ forc build --print-finalized-asm ... .programme : ji i4 noop DATA_SECTION_OFFSET [0..32] DATA_SECTION_OFFSET[32..64] lw $ds $is 1 add $$ds $$ds $is lw $r0 $fp i73 ; charger le s\u00e9lecteur de fonction d'entr\u00e9e lw $r1 data_0 ; charge le s\u00e9lecteur de fn pour la comparaison eq $r2 $r0 $r1 ; comparaison de s\u00e9lecteurs de fonctions jnzi $r2 i12 ; saut \u00e0 la fonction s\u00e9lectionn\u00e9e movi $$tmp i123 ; code sp\u00e9cial pour le s\u00e9lecteur non adapt\u00e9 rvrt $$tmp ; retour en arri\u00e8re si aucun s\u00e9lecteur ne correspond ret $one .donn\u00e9es : data_0 .word 559005003 Contrat compil\u00e9 \"my-fuel-project\". La taille du bytecode est de 60 octets.","title":"Mon premier projet"},{"location":"introduction/forcProject/#un-projet-forc","text":"Pour initialiser un nouveau projet avec Forc, utilisez forc new : forc new mon-projet-carburant Voici le projet que Forc a initialis\u00e9 : $ cd mon-projet-carburant $ tree . \u251c\u2500\u2500\u2500 Forc.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.sw Forc.toml est le fichier de manifeste (similaire \u00e0 Cargo.toml pour Cargo ou package.json pour Node), et d\u00e9finit les m\u00e9tadonn\u00e9es du projet telles que le nom du projet et les d\u00e9pendances. Pour plus d'informations sur la gestion des d\u00e9pendances, voir : ici . [projet] auteurs = [\"Utilisateur\"] entr\u00e9e = \"main.sw\" license = \"Apache-2.0 name = \"my-fuel-project\" [d\u00e9pendances] Voici le contenu du seul fichier Sway du projet, et le point d'entr\u00e9e principal, src/main.sw : contrat ; abi MonContrat { fn test_function() -> bool ; } impl MonContrat pour Contrat { fn test_function() -> bool { true } } Le projet est un contrat , l'un des quatre types de projet diff\u00e9rents. Pour plus d'informations sur les diff\u00e9rents types de projets, voir ici . Nous compilons maintenant notre projet avec forc build , en passant le flag --print-finalized-asm pour voir l'assemblage g\u00e9n\u00e9r\u00e9 : $ forc build --print-finalized-asm ... .programme : ji i4 noop DATA_SECTION_OFFSET [0..32] DATA_SECTION_OFFSET[32..64] lw $ds $is 1 add $$ds $$ds $is lw $r0 $fp i73 ; charger le s\u00e9lecteur de fonction d'entr\u00e9e lw $r1 data_0 ; charge le s\u00e9lecteur de fn pour la comparaison eq $r2 $r0 $r1 ; comparaison de s\u00e9lecteurs de fonctions jnzi $r2 i12 ; saut \u00e0 la fonction s\u00e9lectionn\u00e9e movi $$tmp i123 ; code sp\u00e9cial pour le s\u00e9lecteur non adapt\u00e9 rvrt $$tmp ; retour en arri\u00e8re si aucun s\u00e9lecteur ne correspond ret $one .donn\u00e9es : data_0 .word 559005003 Contrat compil\u00e9 \"my-fuel-project\". La taille du bytecode est de 60 octets.","title":"Un projet Forc"},{"location":"introduction/installation/","text":"Installation La Sway toolchain est suffisante pour compiler les smart contracts Sway. Sinon, notez que si vous voulez ex\u00e9cuter des smart contracts Sway (par exemple pour des tests), un n\u0153ud complet Fuel Core est n\u00e9cessaire, que vous trouverez avec la Sway toolchain en tant que Fuel toolchain . Installation \u00e0 partir de fichier binaires pr\u00e9-compil\u00e9s Des fichier binaires pr\u00e9-compil\u00e9s pour Linux et macOS sont disponibles pour la Sway toolchain. Windows natif n'est actuellement pas pris en charge ( suivre le ticket d\u00e9di\u00e9 au support Windows ). Le sous-syst\u00e8me Windows pour Linux devrait fonctionner mais n'est pas officiellement support\u00e9. fuelup est l'\u00e9quivalent de rustup de Rust pour la Fuel toolchain. Il permet de t\u00e9l\u00e9charger facilement des versions binaires de la Fuel toolchain. Commencez par installer fuelup avec : curl --proto '=https' --tlsv1.2 -sSf \\ https://fuellabs.github.io/fuelup/fuelup-init.sh | sh fuelup-init vous demandera la permission d'ajouter ~/.fuelup/bin \u00e0 votre PATH. Sinon, vous pouvez aussi passer --no-modify-path pour que fuelup-init ne modifie pas votre PATH : curl --proto '=https' --tlsv1.2 -sSf \\ https://fuellabs.github.io/fuelup/fuelup-init.sh | sh -s -- --no-modify-path Une fois fuelup install\u00e9, fuelup-init ex\u00e9cute automatiquement la commande suivante fuelup toolchain install latest pour installer la derni\u00e8re version de la Fuel toolchain. Vous pouvez ex\u00e9cuter la m\u00eame commande plus tard pour mettre \u00e0 jour la toolchain. Installation \u00e0 partir des sources D\u00e9pendances La toolchain Rust est un pr\u00e9requis pour installer et utiliser Sway. Les instructions sp\u00e9cifiques \u00e0 la plateforme pour installer rustup peuvent \u00eatre trouv\u00e9es ici . Ensuite, installez la toolchain Rust avec : # Installez la derni\u00e8re toolchain Rust stable. rustup install stable L'installation de fuel-core peut n\u00e9cessiter l'installation de d\u00e9pendances syst\u00e8me suppl\u00e9mentaires. Voir ici pour les instructions. La toolchain Sway est construite et test\u00e9e avec la version stable de la toolchain Rust ( https://github.com/rust-lang/rust/releases/latest ). Il n'y a aucune garantie qu'elle fonctionnera avec la toolchain Rust nightly , ou avec des versions stable ant\u00e9rieures, donc assurez-vous que vous utilisez stable avec : # Mettre \u00e0 jour la toolchain Rust install\u00e9e ; peut \u00eatre utilis\u00e9 ind\u00e9pendamment. rustup update # D\u00e9finir la toolchain Rust stable par d\u00e9faut ; peut \u00eatre utilis\u00e9 ind\u00e9pendamment. rustup default stable Installation \u00e0 partir de Cargo La toolchain Sway et le n\u0153ud complet Fuel Core peuvent \u00eatre install\u00e9s \u00e0 partir des sources avec Cargo : cargo install forc fuel-core Mise \u00e0 jour de forc depuis Cargo Vous pouvez mettre \u00e0 jour la toolchain depuis les sources avec Cargo avec : cargo install forc fuel-core Installation des plugins forc depuis Cargo L'\u00e9cosyst\u00e8me Fuel poss\u00e8de quelques plugins qui peuvent \u00eatre facilement install\u00e9s via Cargo. Note : forc d\u00e9tecte tout ce qui se trouve dans votre $PATH pr\u00e9fix\u00e9 avec forc- comme un plugin. Utilisez forc plugins pour voir ce que vous avez actuellement install\u00e9. # Formateur Sway cargo install forc-fmt # Explorateur de blocs cargo install forc-explore # Serveur de langue Sway cargo install forc-lsp Construire \u00e0 partir des sources Plut\u00f4t que d'installer \u00e0 partir de cargo , la toolchain Sway peut \u00eatre construite \u00e0 partir d'un checkout local des sources en suivant les instructions \u00e0 https://github.com/FuelLabs/sway . L'impl\u00e9mentation compl\u00e8te du n\u0153ud Fuel Core peut \u00eatre construite \u00e0 partir des sources en suivant les instructions de https://github.com/FuelLabs/fuel-core . Activer la compl\u00e9tion de tabulation pour Bash, Fish, Zsh ou PowerShell forc supporte la g\u00e9n\u00e9ration de scripts de compl\u00e9tion pour Bash, Fish, Zsh, et PowerShell. Voir forc completions --help pour plus de d\u00e9tails, mais l'essentiel est aussi simple que d'utiliser un des \u00e9l\u00e9ments suivants : # Bash forc completions --shell=bash > ~/.local/share/bash-completion/completions/forc # Bash (macOS/Homebrew) forc completions --shell=bash > $(brew --prefix)/etc/bash_completion.d/forc.bash-completion # Poisson mkdir -p ~/.config/fish/completions forc completions --shell=fish > ~/.config/fish/completions/forc.fish # Zsh forc completions --shell=zsh > ~/.zfunc/_forc # PowerShell v5.0+ compl\u00e9tions forc --shell=powershell >> $PROFILE.CurrentUserCurrentHost # ou forc completions --shell=powershell | Out-String | Invoke-Expression Une fois que les compl\u00e9tions ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9es et correctement install\u00e9es, fermez et rouvrez votre terminal pour que les nouvelles compl\u00e9tions prennent effet.","title":"Installation"},{"location":"introduction/installation/#installation","text":"La Sway toolchain est suffisante pour compiler les smart contracts Sway. Sinon, notez que si vous voulez ex\u00e9cuter des smart contracts Sway (par exemple pour des tests), un n\u0153ud complet Fuel Core est n\u00e9cessaire, que vous trouverez avec la Sway toolchain en tant que Fuel toolchain .","title":"Installation"},{"location":"introduction/installation/#installation-a-partir-de-fichier-binaires-pre-compiles","text":"Des fichier binaires pr\u00e9-compil\u00e9s pour Linux et macOS sont disponibles pour la Sway toolchain. Windows natif n'est actuellement pas pris en charge ( suivre le ticket d\u00e9di\u00e9 au support Windows ). Le sous-syst\u00e8me Windows pour Linux devrait fonctionner mais n'est pas officiellement support\u00e9. fuelup est l'\u00e9quivalent de rustup de Rust pour la Fuel toolchain. Il permet de t\u00e9l\u00e9charger facilement des versions binaires de la Fuel toolchain. Commencez par installer fuelup avec : curl --proto '=https' --tlsv1.2 -sSf \\ https://fuellabs.github.io/fuelup/fuelup-init.sh | sh fuelup-init vous demandera la permission d'ajouter ~/.fuelup/bin \u00e0 votre PATH. Sinon, vous pouvez aussi passer --no-modify-path pour que fuelup-init ne modifie pas votre PATH : curl --proto '=https' --tlsv1.2 -sSf \\ https://fuellabs.github.io/fuelup/fuelup-init.sh | sh -s -- --no-modify-path Une fois fuelup install\u00e9, fuelup-init ex\u00e9cute automatiquement la commande suivante fuelup toolchain install latest pour installer la derni\u00e8re version de la Fuel toolchain. Vous pouvez ex\u00e9cuter la m\u00eame commande plus tard pour mettre \u00e0 jour la toolchain.","title":"Installation \u00e0 partir de fichier binaires pr\u00e9-compil\u00e9s"},{"location":"introduction/installation/#installation-a-partir-des-sources","text":"","title":"Installation \u00e0 partir des sources"},{"location":"introduction/installation/#dependances","text":"La toolchain Rust est un pr\u00e9requis pour installer et utiliser Sway. Les instructions sp\u00e9cifiques \u00e0 la plateforme pour installer rustup peuvent \u00eatre trouv\u00e9es ici . Ensuite, installez la toolchain Rust avec : # Installez la derni\u00e8re toolchain Rust stable. rustup install stable L'installation de fuel-core peut n\u00e9cessiter l'installation de d\u00e9pendances syst\u00e8me suppl\u00e9mentaires. Voir ici pour les instructions. La toolchain Sway est construite et test\u00e9e avec la version stable de la toolchain Rust ( https://github.com/rust-lang/rust/releases/latest ). Il n'y a aucune garantie qu'elle fonctionnera avec la toolchain Rust nightly , ou avec des versions stable ant\u00e9rieures, donc assurez-vous que vous utilisez stable avec : # Mettre \u00e0 jour la toolchain Rust install\u00e9e ; peut \u00eatre utilis\u00e9 ind\u00e9pendamment. rustup update # D\u00e9finir la toolchain Rust stable par d\u00e9faut ; peut \u00eatre utilis\u00e9 ind\u00e9pendamment. rustup default stable","title":"D\u00e9pendances"},{"location":"introduction/installation/#installation-a-partir-de-cargo","text":"La toolchain Sway et le n\u0153ud complet Fuel Core peuvent \u00eatre install\u00e9s \u00e0 partir des sources avec Cargo : cargo install forc fuel-core","title":"Installation \u00e0 partir de Cargo"},{"location":"introduction/installation/#mise-a-jour-de-forc-depuis-cargo","text":"Vous pouvez mettre \u00e0 jour la toolchain depuis les sources avec Cargo avec : cargo install forc fuel-core","title":"Mise \u00e0 jour de forc depuis Cargo"},{"location":"introduction/installation/#installation-des-plugins-forc-depuis-cargo","text":"L'\u00e9cosyst\u00e8me Fuel poss\u00e8de quelques plugins qui peuvent \u00eatre facilement install\u00e9s via Cargo. Note : forc d\u00e9tecte tout ce qui se trouve dans votre $PATH pr\u00e9fix\u00e9 avec forc- comme un plugin. Utilisez forc plugins pour voir ce que vous avez actuellement install\u00e9. # Formateur Sway cargo install forc-fmt # Explorateur de blocs cargo install forc-explore # Serveur de langue Sway cargo install forc-lsp","title":"Installation des plugins forc depuis Cargo"},{"location":"introduction/installation/#construire-a-partir-des-sources","text":"Plut\u00f4t que d'installer \u00e0 partir de cargo , la toolchain Sway peut \u00eatre construite \u00e0 partir d'un checkout local des sources en suivant les instructions \u00e0 https://github.com/FuelLabs/sway . L'impl\u00e9mentation compl\u00e8te du n\u0153ud Fuel Core peut \u00eatre construite \u00e0 partir des sources en suivant les instructions de https://github.com/FuelLabs/fuel-core .","title":"Construire \u00e0 partir des sources"},{"location":"introduction/installation/#activer-la-completion-de-tabulation-pour-bash-fish-zsh-ou-powershell","text":"forc supporte la g\u00e9n\u00e9ration de scripts de compl\u00e9tion pour Bash, Fish, Zsh, et PowerShell. Voir forc completions --help pour plus de d\u00e9tails, mais l'essentiel est aussi simple que d'utiliser un des \u00e9l\u00e9ments suivants : # Bash forc completions --shell=bash > ~/.local/share/bash-completion/completions/forc # Bash (macOS/Homebrew) forc completions --shell=bash > $(brew --prefix)/etc/bash_completion.d/forc.bash-completion # Poisson mkdir -p ~/.config/fish/completions forc completions --shell=fish > ~/.config/fish/completions/forc.fish # Zsh forc completions --shell=zsh > ~/.zfunc/_forc # PowerShell v5.0+ compl\u00e9tions forc --shell=powershell >> $PROFILE.CurrentUserCurrentHost # ou forc completions --shell=powershell | Out-String | Invoke-Expression Une fois que les compl\u00e9tions ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9es et correctement install\u00e9es, fermez et rouvrez votre terminal pour que les nouvelles compl\u00e9tions prennent effet.","title":"Activer la compl\u00e9tion de tabulation pour Bash, Fish, Zsh ou PowerShell"},{"location":"introduction/introduction/","text":"Introduction Pour commencer \u00e0 d\u00e9velopper des smart contracts Forc et Sway , vous devrez installer la Fuel toolchain et un n\u0153ud complet Fuel ainsi que configurer votre premier projet. Installation Commencer La Fuel toolchain Premier projet Forc Biblioth\u00e8que standard","title":"Introduction"},{"location":"introduction/introduction/#introduction","text":"Pour commencer \u00e0 d\u00e9velopper des smart contracts Forc et Sway , vous devrez installer la Fuel toolchain et un n\u0153ud complet Fuel ainsi que configurer votre premier projet. Installation Commencer La Fuel toolchain Premier projet Forc Biblioth\u00e8que standard","title":"Introduction"},{"location":"introduction/toolchainFuel/","text":"The Fuel Toolchain La toolchain Fuel est constitu\u00e9e de plusieurs composants. Forc ( forc ) Le \"Fuel Orchestrator\" Forc est notre \u00e9quivalent du Cargo de Rust. C'est le principal point d'entr\u00e9e pour cr\u00e9er, construire, tester et d\u00e9ployer des projets Sway. Sway Language Server ( forc-lsp ) Le serveur de langage Sway forc-lsp est fourni pour exposer des fonctionnalit\u00e9s aux IDEs. Instructions d'installation . Actuellement, seul Visual Studio Code est support\u00e9 par un plugin . Le support de Vim est \u00e0 venir, bien que la coloration syntaxique soit fournie . Note : Il n'est pas n\u00e9cessaire de lancer manuellement forc-lsp (le plugin le lancera automatiquement), cependant forc et forc-lsp doivent \u00eatre dans votre $PATH . Pour v\u00e9rifier si forc est dans votre $PATH , tapez forc --help dans votre terminal. Sway Formatter ( forc-fmt ) Un formateur canonique est fourni avec forc-fmt . Instructions d'installation . Il peut \u00eatre lanc\u00e9 manuellement avec forc fmt Le plugin Visual Studio Code formatera automatiquement les fichiers Sway avec forc-fmt lors de la sauvegarde. Fuel Core ( fuel-core ) Une impl\u00e9mentation du protocole Fuel, Fuel Core , est fournie avec la Sway toolchain pour former la Fuel toolchain . Le SDK Rust d\u00e9marrera et arr\u00eatera automatiquement une instance du n\u0153ud pendant les tests, il n'est donc pas n\u00e9cessaire d'ex\u00e9cuter manuellement un n\u0153ud \u00e0 moins d'utiliser Forc directement sans le SDK.","title":"toolchainFuel"},{"location":"introduction/toolchainFuel/#the-fuel-toolchain","text":"La toolchain Fuel est constitu\u00e9e de plusieurs composants.","title":"The Fuel Toolchain"},{"location":"introduction/toolchainFuel/#forc-forc","text":"Le \"Fuel Orchestrator\" Forc est notre \u00e9quivalent du Cargo de Rust. C'est le principal point d'entr\u00e9e pour cr\u00e9er, construire, tester et d\u00e9ployer des projets Sway.","title":"Forc (forc)"},{"location":"introduction/toolchainFuel/#sway-language-server-forc-lsp","text":"Le serveur de langage Sway forc-lsp est fourni pour exposer des fonctionnalit\u00e9s aux IDEs. Instructions d'installation . Actuellement, seul Visual Studio Code est support\u00e9 par un plugin . Le support de Vim est \u00e0 venir, bien que la coloration syntaxique soit fournie . Note : Il n'est pas n\u00e9cessaire de lancer manuellement forc-lsp (le plugin le lancera automatiquement), cependant forc et forc-lsp doivent \u00eatre dans votre $PATH . Pour v\u00e9rifier si forc est dans votre $PATH , tapez forc --help dans votre terminal.","title":"Sway Language Server (forc-lsp)"},{"location":"introduction/toolchainFuel/#sway-formatter-forc-fmt","text":"Un formateur canonique est fourni avec forc-fmt . Instructions d'installation . Il peut \u00eatre lanc\u00e9 manuellement avec forc fmt Le plugin Visual Studio Code formatera automatiquement les fichiers Sway avec forc-fmt lors de la sauvegarde.","title":"Sway Formatter (forc-fmt)"},{"location":"introduction/toolchainFuel/#fuel-core-fuel-core","text":"Une impl\u00e9mentation du protocole Fuel, Fuel Core , est fournie avec la Sway toolchain pour former la Fuel toolchain . Le SDK Rust d\u00e9marrera et arr\u00eatera automatiquement une instance du n\u0153ud pendant les tests, il n'est donc pas n\u00e9cessaire d'ex\u00e9cuter manuellement un n\u0153ud \u00e0 moins d'utiliser Forc directement sans le SDK.","title":"Fuel Core (fuel-core)"}]}